<!doctype html>
<html>
  <head>
    <meta http-enquiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="READ.css">
    <title>Шпаргалка</title>
  </head>
  <body>

    <p>1.html, pages/2.html - примеры статичных страниц.</p>
    <hr>

    <table>
      <caption>Список товаров</caption>
      <tr>
        <th>category</th>
        <th>name</th>
        <th>description</th>
        <th>price</th>
        <th>in_stock</th>
      </tr>
      <tr>
        <td>Веники</td>
        <td>B-1</td>
        <td>Классическая конструкция из<br>экологически чистых материалов</td>
        <td>100</td>
        <td>*</td>
      </tr>
      <tr>
        <td>Веники</td>
        <td>В-2М</td>
        <td>Усовершенствованная конструкция,<br>выполненная с применением особо<br>прочной синтетики</td>
        <td>200</td>
        <td></td>
      </tr>
      <tr>
        <td>Веники</td>
        <td>В-2000</td>
        <td>Современная конструкция,<br>выполненная с применением<br>нанотехнологий</td>
        <td>2000</td>
        <td>*</td>
      </tr>
      <tr>
        <td>Мётлы</td>
        <td>М-1</td>
        <td>Классическая конструкция из<br>экологически чистых материалов</td>
        <td>150</td>
        <td>*</td>
      </tr>
      <tr>
        <td>Мётлы</td>
        <td>М-2014О</td>
        <td>Выпущена в честь Зимней<br>олимпиады в Сочи 2014 года</td>
        <td>15000</td>
        <td>*</td>
      </tr>
    </table>
    <hr>

    <table>
      <caption>Классы наиболее часто встречающихся исключений</caption>
      <tr>
        <th>Класс исключения</th>
        <th>Описание</th>
      </tr>
      <tr>
        <td>AttributeError</td>
        <td>Ошибка обращения к свойству или методу класса</td>
      </tr>
      <tr>
        <td>IndentationError</td>
        <td>Некорректный отступ</td>
      </tr>
      <tr>
        <td>IndexError</td>
        <td>Список не имеет элемента с таким индексом</td>
      </tr>
      <tr>
        <td>KeyError</td>
        <td>Словарь не имеет элемента с таким ключом</td>
      </tr>
      <tr>
        <td>NameError</td>
        <td>Переменная, функция или класс с таким именем не существует</td>
      </tr>
      <tr>
        <td>NotImplementedError</td>
        <td>Данный метод в классе не реализован</td>
      </tr>
      <tr>
        <td>OverflowError</td>
        <td>Слишком большое число</td>
      </tr>
      <tr>
        <td>RuntimeError</td>
        <td>Нераспознанная ошибка времени выполнения</td>
      </tr>
      <tr>
        <td>SyntaxError</td>
        <td>Ошибка в записи кода (синтаксическая ошибка)</td>
      </tr>
      <tr>
        <td>TabError</td>
        <td>Отступ задан табуляциями, а не пробелами</td>
      </tr>
      <tr>
        <td>TypeError</td>
        <td>Неверный тип параметра функции или метода; свойство или метод не поддерживается классом</td>
      </tr>
      <tr>
        <td>UnicodeError</td>
        <td>Возникла проблема при раскодировании строки, заданной в кодировке UTF-8</td>
      </tr>
      <tr>
        <td>ValueError</td>
        <td>Неверное значение аргумента оператора, параметра функции или метода</td>
      </tr>
      <tr>
        <td>ZeroDivisionError</td>
        <td>Деление на ноль</td>
      </tr>
    </table>
    <hr>

    <table>
      <caption>Модификаторы фильтрации (&lt;Class&gt;.objects.&lt;filter|exclude&gt;(&lt;field&gt;__&lt;mod&gt; = &lt;value&gt;))</caption>
      <tr>
        <th>Модификатор</th>
        <th>Описание</th>
        <th>Тип данных</th>
      </tr>
      <tr>
        <td>exact</td>
        <td>Значение поля должно быть равно указанному (это поведение по умолчанию, так что данный модификатор можно не указывать)</td>
        <td rowspan=3>Любой</td>
      </tr>
      <tr>
        <td>in</td>
        <td>Значение поля должно быть равно одному из указанных. Сравниваемые значения задаются в виде списка</td>
      </tr>
      <tr>
        <td>isnull</td>
        <td>Поле должно (True) или не должно (False) содержать какое-либо значение</td>
      </tr>
      <tr>
        <td>iexact</td>
        <td>То же самое, что exact, но без учёта регистра символов</td>
        <td rowspan=7>Строка</td>
      </tr>
      <tr>
        <td>contains</td>
        <td>Значение поля должно содержать указанное нами</td>
      </tr>
      <tr>
        <td>icontains</td>
        <td>То же самое, что contains, но без учёта регистра символов</td>
      </tr>
      <tr>
        <td>startswith</td>
        <td>Значение поля должно начинаться с указанного нами</td>
      </tr>
      <tr>
        <td>istartswith</td>
        <td>То же самое, что startswith, но без учёта регистра символов</td>
      </tr>
      <tr>
        <td>endswith</td>
        <td>Значение поля должно заканчиваться указанным нами</td>
      </tr>
      <tr>
        <td>iendswith</td>
        <td>То же самое, что endswith, но без учёта регистра символов</td>
      </tr>
      <tr>
        <td>gt</td>
        <td>Значение поля должно быть больше указанного</td>
        <td rowspan=4>Число</td>
      </tr>
      <tr>
        <td>gte</td>
        <td>Значение поля должно быть больше или равно указанному</td>
      </tr>
      <tr>
        <td>lt</td>
        <td>Значение поля должно быть меньше указанного</td>
      </tr>
      <tr>
        <td>lte</td>
        <td>Значение поля должно быть меньше или равно указанному</td>
      </tr>
      <tr>
        <td>range</td>
        <td>Значение поля должно укладываться в указанный нами диапазон, который задаётся в виде кортежа</td>
        <td>Число, дата, время, дата и время</td>
      </tr>
      <tr>
        <td>year</td>
        <td>Значение поля должно принадлежать к указанному нами году</td>
        <td rowspan=4>Дата, дата и время</td>
      </tr>
      <tr>
        <td>month</td>
        <td>Значение поля должно принадлежать к указанному нами месяцу</td>
      </tr>
      <tr>
        <td>day</td>
        <td>Значение поля должно принадлежать к указанному нами числу</td>
      </tr>
      <tr>
        <td>week_day</td>
        <td>Значение поля должно принадлежать к указанному нами дню недели, который задаётся числом от 1 (воскресенье) до 7 (суббота)</td>
      </tr>
      <tr>
        <td>hour</td>
        <td>Значение поля должно принадлежать к указанному нами часу</td>
        <td rowspan=3>Время, дата и время</td>
      </tr>
      <tr>
        <td>minute</td>
        <td>Значение поля должно принадлежать к указанной нами минуте</td>
      </tr>
      <tr>
        <td>second</td>
        <td>Значение поля должно принадлежать к указанной нами секунде</td>
      </tr>
    </table>
    <hr>

    <table>
      <caption>Классы агрегатных функций (&lt;Class&gt;.objects.aggregate(&lt;aggregate_function()&gt;))</caption>
      <tr>
        <th>Класс</th>
        <th>Описание</th>
      </tr>
      <tr>
        <td>Count(&lt;поле&gt;, &lt;только уникальные значения&gt;)</td>
        <td>
          Количество значений параметра <i>поле</i> (фактически - количество записей). Если необязательный параметр <i>только уникальные значения</i> равен <i>True</i>,
          учитываются только уникальные значения (значение по умолчанию - <i>False</i>)
        </td>
      </tr>
      <tr>
        <td>Avg(&lt;поле&gt;)</td>
        <td>Среднее арифметическое значение параметра <i>поле</i></td>
      </tr>
      <tr>
        <td>Sum(&lt;поле&gt;)</td>
        <td>Сумма значений параметра <i>поле</i></td>
      </tr>
      <tr>
        <td>Max(&lt;поле&gt;)</td>
        <td>Максимальное из значений параметра <i>поле</i></td>
      </tr>
      <tr>
        <td>Min(&lt;поле&gt;)</td>
        <td>Минимальное из значений параметра <i>поле</i></td>
      </tr>
      <tr>
        <td>StdDev(&lt;поле&gt;, &lt;отклонение выборки&gt;)</td>
        <td>
          Стандартное отклонение значений параметра <i>поле</i>. Если необязательный параметр <i>отклонение выборки</i> равен <i>True</i>, рассчитывается стандартное
          отклонение выборки (значение по умочанию - <i>False</i>)
        </td>
      </tr>
      <tr>
        <td>Variance(&lt;поле&gt;, &lt;дисперсия выборки&gt;)</td>
        <td>
          Дисперсия значений параметра <i>поле</i>. Если необязательный параметр <i>отклонение выборки</i> равен <i>True</i>, рассчитывается дисперсия выборки
          (значение по умолчанию - <i>False</i>)
        </td>
      </tr>
    </table>
    <hr>

    <table>
      <caption>Полезные методы класса QuerySet</caption>
      <tr>
        <th>Метод</th>
        <th>Описание</th>
      </tr>
      <tr>
        <td>exists()</td>
        <td>Возвращает <i>True</i>, если набор содержит записи, и <i>False</i> в противном случае</td>
      </tr>
      <tr>
        <td>first()</td>
        <td>Возвращает объект первой записи списка или <i>None</i>, если список пуст</td>
      </tr>
      <tr>
        <td>last()</td>
        <td>Возвращает объект последней записи списка или <i>None</i>, если список пуст</td>
      </tr>
      <tr>
        <td>earliest(&lt;поле&gt;)</td>
        <td>Возвращает объект записи с наименьшим значением параметра <i>поле</i>, которое должно иметь тип даты или даты и времени</td>
      </tr>
      <tr>
        <td>latest(&lt;поле&gt;)</td>
        <td>Возвращает объект записи с наибольшим значением параметра <i>поле</i>, которое должно иметь тип даты или даты и времени</td>
      </tr>
      <tr>
        <td>distinct([&lt;список полей, разделённых запятыми&gt;])</td>
        <td>
          Возвращает набор, включающий лишь уникальные записи. Если не указан <i>список полей</i>, в набор включаются записи, в которых значения всех полей являются
          уникальными. Если список полей присутствует, в набор включаются записи, в которых уникальными являются лишь значения указанных нами полей
        </td>
      </tr>
    </table>
    <hr>

    <table>
      <caption>Литералы регулярных выражений<caption>
      <tr>
        <th>Литерал</th>
        <th>Описание</th>
      </tr>
      <tr>
        <td>.</td>
        <td>Любой символ</td>
      </tr>
      <tr>
        <td>\w</td>
        <td>Буква, цифра или подчёркивание</td>
      </tr>
      <tr>
        <td>\W</td>
        <td>Не буква, не цифра и не подчёркивание</td>
      </tr>
      <tr>
        <td>\d</td>
        <td>Цифра</td>
      </tr>
      <tr>
        <td>\D</td>
        <td>Не цифра</td>
      </tr>
      <tr>
        <td>\s</td>
        <td>Пробельный символ (пробел, табуляция, возврат каретки или перевод строки)</td>
      </tr>
      <tr>
        <td>\S</td>
        <td>Не пробельный символ</td>
      </tr>
      <tr>
        <td>\b</td>
        <td>Начало или конец слова</td>
      </tr>
      <tr>
        <td>\B</td>
        <td>Не начало и не конец слова</td>
      </tr>
      <tr>
        <td>^ и \A</td>
        <td>Начало строки</td>
      </tr>
      <tr>
        <td>$ и \Z</td>
        <td>Конец строки</td>
      </tr>
      <tr>
        <td>[&lt;набор&gt;]</td>
        <td>Любой символ из <i>набора</i></td>
      </tr>
      <tr>
        <td>&lt;A&gt;|&lt;B&gt;</td>
        <td>Либо символ <i>A</i>, либо символ <i>B</i></td>
      </tr>
      <tr>
        <td>*</td>
        <td>Предыдущий символ может присутствовать произвольное количество раз, а может и не присутствовать вообще</td>
      </tr>
      <tr>
        <td>+</td>
        <td>Предыдущий символ должен присутствовать в строке как минимум один раз</td>
      </tr>
      <tr>
        <td>?</td>
        <td>Предыдущий символ должен либо не присутствовать в строке, либо присутствовать один раз</td>
      </tr>
      <tr>
        <td>{&lt;n&gt;}</td>
        <td>Предыдущий символ должен присутствовать в строке строго <i>n</i> раз</td>
      </tr>
      <tr>
        <td>{&lt;m&gt;, &lt;n&gt;}</td>
        <td>Предыдущий символ должен присутствовать в строке от <i>m</i> до <i>n</i> раз</td>
      </tr>
    </table>
    <hr>

    <table>
      <caption>Форматы описания групп</caption>
      <tr>
        <th>Формат группы</th>
        <th>Описание</th>
      </tr>
      <tr>
        <td>(&lt;подстрока&gt;)</td>
        <td>
          Обычная группа, коротая должна совпадать с параметром <i>подстрока</i>. Совпадающая с этой группой подстрока может быть извлечена обращением по порядковому номеру
          группы
        </td>
      </tr>
      <tr>
        <td>(Р&lt;&lt;имя&gt;&gt;&lt;подстрока&gt;</td>
        <td>Обычная группа, но совпадающее значение может быть извлечено путём обращения к имени группы<i></i></td>
      </tr>
      <tr>
        <td>(?Р=&lt;имя&gt;)</td>
        <td>Задаёт последовательность, совпадающую со значением группы с указанным параметром <i>имя</i></td>
      </tr>
      <tr>
        <td>(?=&lt;подстрока&gt;)</td>
        <td>Группа, чьим значением станет фрагмент, за которым следует <i>подстрока</i></td>
      </tr>
      <tr>
        <td>(?!&lt;подстрока&gt;)</td>
        <td>Группа, чьим значением станет фрагмент, за которым не следует <i>подстрока</i></td>
      </tr>
      <tr>
        <td>(?&lt;=&lt;подстрока&gt;)</td>
        <td>Группа, чьим значением станет фрагмент, перед которым следует <i>подстрока</i></td>
      </tr>
      <tr>
        <td>(?&lt;!&lt;подстрока&gt;)</td>
        <td>Группа, чьим значением станет фрагмент, перед которым не следует <i>подстрока</i></td>
      </tr>
      <tr>
        <td>(?:&lt;подстрока&gt;)</td>
        <td>Совпадающее с этой группой значение не может быть извлечено. Применяется лишь для формирования подстроки и обрабатывается быстрее обычных групп</td>
      </tr>
    </table>
    <hr>

    <h1>Теги условных выражений в шаблонах</h1>
    <p>Проверка условий</p>
    <code>
      <pre>
{% if &lt;условие 1&gt; %}
  &lt;блок 1&gt;
[{% elif &lt;условие 2&gt; %}
  &lt;блок 2&gt;
[&lt;прочие теги elif&gt;]]
[{% else %}
  &lt;блок else&gt;]
{% endif %}
      </pre>
    </code>

    <p>Проверка равенства двух значений</p>
    <code>
      <pre>
{% ifequal|ifnotequal &lt;значение 1&gt; &lt;значение 2&gt; %}
  &lt;блок&gt;
{% endifequal|endifnotequal %}
      </pre>
    </code>
    <hr>

  </body>
</html>

